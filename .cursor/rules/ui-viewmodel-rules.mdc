---
description: "UI and ViewModel Rules for Jetpack Compose"
globs: ""
alwaysApply: true
---
# UI and ViewModel Rules

## Business Logic Separation

### ❌ Incorrect Pattern
```kotlin
@Composable
fun PlayerScreen() {
    Button(onClick = {
        // Business logic directly in UI - WRONG
    }) {
        Text("Button")
    }
}
```

### ✅ Correct Pattern
```kotlin
class PlayerViewModel() : ViewModel() {
    fun fetchPlayList() {
        // Business logic here
    }
}

@Composable
fun PlayerScreen(
    playerViewModel: PlayerViewModel
) {
    Button(onClick = {
        playerViewModel.fetchPlayList()
    }) {
        Text("Button")
    }
}
```

## ViewModel Organization Rules

### Higher-Level Feature Organization
Use one ViewModel per major feature, not per sub-feature.

**✅ DO THIS**: Single ViewModel for feature
```kotlin
class LiveViewModel {
    // One ViewModel handles all Live-related features
    fun handleStreaming() { ... }
    fun handleSettings() { ... }
    fun handleChat() { ... }
}
```

**❌ DON'T DO THIS**: Multiple ViewModels for sub-features
```kotlin
class LiveStreamViewModel { ... }  // WRONG
class LiveSettingViewModel { ... }  // WRONG
class LiveChatViewModel { ... }     // WRONG
```

## Composable Components
- Place reusable components in components/ directory
- Each component must be independent
- Follow theme system
- Consider accessibility (ContentDescription required)
- ViewModel naming: `FunctionName + ViewModel`
- Register in `../di/` using Hilt (use `@HiltViewModel` annotation)

## State Management
- Manage state in ViewModel
- Use StateFlow (see [coroutine-rules.mdc](mdc:.cursor/rules/coroutine-rules.mdc) for Flow usage)
- Follow Unidirectional Data Flow (UDF)
- Apply state hoisting pattern
- Use `remember` and `derivedStateOf` for expensive calculations

## Screen Composable Pattern

### ViewModel Injection and State Collection

**✅ Correct Pattern**: Use `hiltViewModel()` and `collectAsStateWithLifecycle()`

```kotlin
@Composable
fun WalkingRoute(
    viewModel: WalkingViewModel = hiltViewModel()
) {
    val uiState by viewModel.uiState.collectAsStateWithLifecycle()

    WalkingScreen(
        uiState = uiState,
        onStartClick = viewModel::onStart,
        onStopClick = viewModel::onStop,
    )
}
```

**Key Rules:**
1. **ViewModel Injection**: Always use `hiltViewModel()` as default parameter value
   - Allows dependency injection via Hilt
   - Enables testing by passing mock ViewModel
   - Example: `viewModel: WalkingViewModel = hiltViewModel()`

2. **State Collection**: Always use `collectAsStateWithLifecycle()` for StateFlow
   - Automatically handles lifecycle (pauses when stopped, resumes when started)
   - Prevents memory leaks
   - Example: `val uiState by viewModel.uiState.collectAsStateWithLifecycle()`

3. **Method References**: Use method references (`::`) for ViewModel callbacks
   - Cleaner syntax: `viewModel::onStart` instead of `{ viewModel.onStart() }`
   - Better performance (no lambda allocation)
   - Example: `onStartClick = viewModel::onStart`

4. **Screen Separation**: Separate screen composable from UI component
   - Screen composable: Handles ViewModel injection and state collection
   - UI component: Receives state and callbacks as parameters
   - Enables reusability and testability

**❌ Incorrect Patterns:**

```kotlin
// WRONG: ViewModel injection without default parameter
@Composable
fun WalkingRoute() {
    val viewModel = hiltViewModel<WalkingViewModel>() // Missing default parameter
    // ...
}

// WRONG: Using collectAsState() instead of collectAsStateWithLifecycle()
@Composable
fun WalkingRoute(
    viewModel: WalkingViewModel = hiltViewModel()
) {
    val uiState by viewModel.uiState.collectAsState() // Missing lifecycle awareness
    // ...
}

// WRONG: Business logic in UI composable
@Composable
fun WalkingRoute(
    viewModel: WalkingViewModel = hiltViewModel()
) {
    val uiState by viewModel.uiState.collectAsStateWithLifecycle()
    
    Button(onClick = {
        // WRONG: Business logic in UI
        viewModel.uiState.value = SomeState()
    }) {
        Text("Button")
    }
}

// WRONG: Lambda instead of method reference
@Composable
fun WalkingRoute(
    viewModel: WalkingViewModel = hiltViewModel()
) {
    val uiState by viewModel.uiState.collectAsStateWithLifecycle()
    
    WalkingScreen(
        uiState = uiState,
        onStartClick = { viewModel.onStart() }, // Use ::onStart instead
    )
}
```

### Screen Structure Template

```kotlin
@Composable
fun FeatureScreen(
    viewModel: FeatureViewModel = hiltViewModel(),
    onNavigateBack: () -> Unit = {},
) {
    val uiState by viewModel.uiState.collectAsStateWithLifecycle()
    
    FeatureScreenContent(
        uiState = uiState,
        onAction1 = viewModel::handleAction1,
        onAction2 = viewModel::handleAction2,
        onNavigateBack = onNavigateBack,
    )
}

@Composable
private fun FeatureScreenContent(
    uiState: FeatureUiState,
    onAction1: () -> Unit,
    onAction2: () -> Unit,
    onNavigateBack: () -> Unit,
) {
    // UI implementation
}
```

## Navigation
- Use Compose Navigation
- Support Deep Links
- Implement screen transition animations
- Handle backstack management

## Error Handling
- User-friendly error messages
- Implement retry mechanisms
- Error logging and analytics
- Use Result type for error handling (see [result-handling-rules.mdc](mdc:.cursor/rules/result-handling-rules.mdc))

## Code Style

### Naming Conventions
- Classes: PascalCase
- Functions: camelCase
- Variables: camelCase
- Constants: SCREAMING_SNAKE_CASE
- Composable Functions: PascalCase

### Composable Function Rules
- Must include Preview functions
- Parameters must have explicit default values
- Apply state hoisting
- Reusable components should be in separate files

### Code Formatting
- Indentation: 4 spaces
- Maximum line length: 120 characters
- Maximum function length: 50 lines
- Maximum file length: 500 lines
- Comments: Write in Korean
- Use KDoc format for documentation

### Technical Specifications
- **Language**: Kotlin
- **Framework**: Jetpack Compose
- **Architecture**: MVVM + Clean Architecture
- **File Coverage**: Write all parts without omission



